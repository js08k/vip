#include "vbase.h"
#include "vheap.h"
#include "vconfig.h"
#include "vportable.h"
#include "voverlay.h"
#include "vtypes.h"
#include "vmang.h"
#include "vfilter.h"
#include "vstring.h"
#include "varp.h"
#include "vipv4.h"

// Constants global to the ipstack (external variables):
// MAC address constants
const hwaddr vMac_broadcast = { BROADCASTMAC };
const hwaddr vMac_localaddr = { DEFAULTMAC };

// Constants global to vBase.c:

/*!
 * \brief vInitializeBase Responsable for initializing the MAC level controls.
 * To include any functions needed by the MAC controlling software as well as
 * the call to initialize of the hardware.
 */
void vInitializeBase( void )
{
    // Initialize all of the hardware aspect
    vInitializeHardware();
}

/*!
 * \brief vPutMACpacket
 * \param dest
 * \param type
 * \param ploc
 */
void vPutMACpacket( const hwaddr dest, uint16_t type, void *ploc )
{
    uint16_t datn;
    switch( type )
    {
    case ARPTYPE:
        datn = 28;
        break;
    case IPv4TYPE:
        datn = hton16( IPv4(ploc)->TotalLength );
        break;
    default:
        datn = 0;
        break;
    }

    /* Source MAC address is this device */
    hwaddr_cpy( &MAC(ploc)->sourc, &vMac_localaddr );

    hwaddr_cpy( &MAC(ploc)->dest, &dest );

    /* Set the packet type (ARP, IPv4, ... etc ) */
    MAC(ploc)->type = hton16(type);

    /* Write the packet to the hardware controller and send */
    vEthernetWrite( ploc, datn + sizeof( tagMACgram ) );
}

/****************************************************************************
vPutMACpacket:
    DESCRIPTION
        This function deals with layer 2 of the OSI model.
        It is designed to read an entire packet into memory from the hardware
        buffers, and then analyze & act accordingly to the ethernet frames

    FUNCTION REQUIRMENTS
        - Shall return the port corresponding to where the packet is directed,
        since this is a higher layer function, this requirement shall only be
        met when vIPnotifyPort has met the requirement.

        - Upon receiving packets destined for addresses other than ones this
        device possesses the memory shall be freed and 0xFF shall be returned
        indicating the packet was dropped for unspecified reasons.

        - Shall allocate memory to hold a packet and, upon unavailability of
        the memory, handle handle the error with care such that the packet will
        not be dropped because of insufficient memory.

        - Shall ensure all memory is either freed or shall be freed at a later
        time, no valid pointers are lost when this function leaves execution.
 ****************************************************************************/
void vGetMACpacket( void )
{
    // Disable interrupts generated by receiving Ethernet packets
    vEthernetIntDisable();

    // Clear the flags that generated this interrupt
    vEthernetIntClear();

    void* ploc = ucalloc( 1500 );

    if( !ploc )
    {
        // Drop the packet, we arn't able to handle memory for the packet.
        vEthernetClear();

        // Enable interrupts to be generated by receiving Ethernet packets
        vEthernetIntEnable();

        // Return from this call
        return;
    }

    // Read the MAC header from the hardware
    int size = vEthernetRead( ploc, 1500 );

    // If more than zero bytes of data was read in
    if( size > 0 )
    {
        // This is a shrink or not a size change and will always succeed.
        ploc = ucrealloc( ploc, size );

        // Perform a byte reorder on the packet type
        MAC(ploc)->type = hton16( MAC(ploc)->type );

        // since data was read, deallocation of ploc is handled by the manager.
        vMangQueueRX( ploc );
    }
    else
    {
        // Since no data was read and ploc was allocated, this must be
        // deallocated
        ucfree( ploc );
    }

    // Enable interrupts to be generated by receiving Ethernet packets
    vEthernetIntEnable();
}

/******************************************************************
 * hton16()
 * 	used for converting between little-endian data and
 * big-endian data of a 16 bit number.
 ******************************************************************/
uint16_t hton16( uint16_t input )
{
#ifdef LITTLE_ENDIAN
    // switch upper byte with lower byte
    // and return
    return ( input << 8 | input >> 8 );
#else
#ifdef BIG_ENDIAN
    return input;
#else
#error "Endian must be defined.";
#endif
#endif
}

/******************************************************************
 * hton32()
 * 	used for converting between little-endian data and
 * big-endian data of a 32 bit number.
 ******************************************************************/
uint32_t hton32( uint32_t input )
{
#ifdef LITTLE_ENDIAN
    return ( hton16( (uint16_t)( input >> 16) ) |
             ( hton16( (uint16_t)input ) << 16 ) );
#else
#ifdef BIG_ENDIAN
    return input;
#else
#error "Endian must be defined.";
#endif
#endif
}
