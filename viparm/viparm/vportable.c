/************************************
 * Virtual IP stack					*
 * File:	vIPportable.c			*
 * Author:	Joshua Strickland		*
 * Date:	November 2010			*
 * Version:	1.0						*
 ************************************/
#include "vportable.h"
#include "vconfig.h"
#include "vheap.h"
#include "vstring.h"
#include "vbase.h"
#include "vtypes.h"

// Hardware driver's includes
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_ints.h"
#include "driverlib/ethernet.h"
#include "driverlib/gpio.h"
#include "driverlib/timer.h"
#include "driverlib/interrupt.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/gpio.h"

void vInitializeEthernet( void );
void vRealTimeTimerInt( void );

int global_clock;

void vInitializeHardware( void )
{
    // todo: Move this out into an initialization for GPIO
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);

    // Initialize the Ethernet peripheral
    vInitializeEthernet();

    // Initialize the Timer peripheral
    vInitializeMsTime();
}

void vInitializeEthernet( void )
{
    // Enable the Ethernet peripheral
    SysCtlPeripheralEnable( SYSCTL_PERIPH_ETH );

    // Initialize the Ethernet peripheral
    EthernetInitExpClk( ETH_BASE, SysCtlClockGet() );

    // Ensure all Ethernet interrupts are disabled.
    EthernetIntDisable( ETH_BASE, ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
                        ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER | ETH_INT_RX );

    // Set the Hardware MAC address for the Ethernet to use. This is done
    // because the Ethernet will not function as a permiscuous controller
    EthernetMACAddrSet( ETH_BASE, (unsigned char *)vMac_localaddr.data );

    // Configure the Ethernet peripheral
    // ETH_CFG_TX_DPLXEN: Enable Full duplex
    // ETH_CFG_TX_CRCEN: Enable transmit with auto CRC generation
    // ETH_CFG_TX_PADEN: Enable padding of transmit data to minimum size
    EthernetConfigSet( ETH_BASE, ETH_CFG_TX_DPLXEN |
                       ETH_CFG_TX_CRCEN | ETH_CFG_TX_PADEN );

    // Enable the Ethernet peripheral
    EthernetEnable( ETH_BASE );

    // Register the Ethernet interrupt handler
    IntRegister( INT_ETH, vGetMACpacket );

    // Enable interrupts to be generated by the Ethernet peripheral
    IntEnable( INT_ETH );

    // Clear the Ethernet interrupt (only rx causes an interrupt)
    vEthernetIntClear();

    // Enable interrupts to be generated by the RX of the Ethernet peripheral
    vEthernetIntEnable();
}

void vEthernetIntEnable(void)
{
    // Allow interrupts generated by the RX of the Ethernet peripheral
    EthernetIntEnable(ETH_BASE, ETH_INT_RX);
}

void vEthernetIntDisable(void)
{
    // Disable interrupts generated by the RX of the Ethernet peripheral
    EthernetIntDisable(ETH_BASE, ETH_INT_RX);
}

void vEthernetIntClear( void )
{
    // Clear the Ethernet Interrupt
    EthernetIntClear( ETH_BASE, EthernetIntStatus( ETH_BASE, 0 ) );
}

void vEthernetWrite( const void* base, int datl )
{
    // This is a blocking call and will wait until the transmit buffer is empty
    // in the ethernet controller
    EthernetPacketPut( ETH_BASE, (unsigned char*)base, (long)datl );
}

int vEthernetRead( void* base, int datl )
{
    // Read a packet from the Ethernet controller up to the size allowed by the
    // buffer passed.
    sint32_t size = EthernetPacketGetNonBlocking(
                ETH_BASE, (unsigned char*)base, (long)datl );

    if( size < 0 )
    {
        // The full packet was not read because the buffer was too small.
        // Returning the size of the buffer since this was all that was read.
        return datl;
    }
    else
    {
        // The buffer was sufficent to hold the packet, returning the number
        // of bytes that was read by this call.
        return size;
    }
}

int vEthernetPending( void )
{
    // This function is not supported by this Ethernet controller because when
    // EthernetPacketGet or EthernetPacketGetNonBlocking is called, the buffer
    // is emptied regardless of whether the full packet was read
    return 0;

    // This will result in zero if no packet is available, it will result
    // in the number of bytes that are pending to read if a packet is
    // available.
    return ( 0 - EthernetPacketGetNonBlocking( ETH_BASE, 0, 0 ) );
}

void vEthernetClear( void )
{
    // When EthernetPacketGet or EthernetPacketGetNonBlocking is called no data
    // will be read, but the packet will be dropped because of the way these
    // functions are implemented.
    EthernetPacketGetNonBlocking( ETH_BASE, 0, 0 );
}

void vInitializeMsTime()
{
    // Enable the Timer0 peripheral
    SysCtlPeripheralEnable( SYSCTL_PERIPH_TIMER0 );

    // Ensure the timer is disabled before configuring the timer.
    TimerDisable( TIMER0_BASE, TIMER_BOTH );

    // Configure a 32 bit down counting periodic timer
    TimerConfigure( TIMER0_BASE, TIMER_CFG_32_BIT_PER );

    // This stops the timer while we are in debug (trying to program)
    // preventing the double free exception that annoyingly occurs.
    TimerControlStall( TIMER0_BASE, TIMER_A, true );

    // Disable ALL interrupts that might have been previously enabled
    TimerIntDisable( TIMER0_BASE, TIMER_CAPB_EVENT | TIMER_CAPB_MATCH |
                     TIMER_TIMB_TIMEOUT | TIMER_RTC_MATCH | TIMER_CAPA_EVENT |
                     TIMER_CAPA_MATCH | TIMER_TIMA_TIMEOUT );

    // Set the interrupt to occur once a second (we don't have an exact clock,
    // but close enough for gov work). Assuming the clock is a 50Mhz clock
    TimerLoadSet( TIMER0_BASE, TIMER_A, 50000 );

    // Enable the timer
    TimerEnable( TIMER0_BASE, TIMER_A );

    // Clear pre-existing interrupts from this timer
    TimerIntClear( TIMER0_BASE, TimerIntStatus( TIMER0_BASE, 0 ) );

    // Enable interrupts from the timerout event
    TimerIntEnable( TIMER0_BASE, TIMER_TIMA_TIMEOUT );

    // Register the timer interrupt to be used
    IntRegister( INT_TIMER0A, vTimerInterrupt );

    // Enable timer interrupts from the timer
    IntEnable( INT_TIMER0A );

    // Initialize the global_clock to zero
    global_clock = 0;
}

void vRealTimeTimerInt( void )
{
    static int i = 0;

    if( i == 0 )
    {
        setDebugLed( 1 );

        i = 1;
    }
    else
    {
        setDebugLed( 0 );

        i = 0;
    }
}

void vTimerInterrupt( void )
{
    // Clear this timer's interrupt flag
    TimerIntClear( TIMER0_BASE, TimerIntStatus( TIMER0_BASE, 0 ) );

    // Increment the global ms clock
    // This number will "roll over" every 50 days. (give or take a few days)
    ++global_clock;

    // -- Below this in this function is for debug purposes --

    // Led periodic flash counter
    static int i = 0;

    // Increment i, the flash counter
    ++i;

    // Toggle the led on & off every .5 seconds.
    if( i >= 1000 )
    {
        // Counter has reached 1 second, turn on the LED
        setDebugLed( 1 );

        // Reset the counter to zero
        i = 0;
    }
    else if( i == 500 )
    {
        // Counter has reached 500 mS (.5 seconds), turn off the LED
        setDebugLed( 0 );
    }
}

int msTime()
{
    // todo: correctly implement msTime;
    return global_clock;
}

// All functions below are for debugging purposes and should be removed before
// a production environment is assumed.
// Debug includes
#include "voverlay.h"
#include "vbase.h"

void setDebugLed( int state )
{
    if( state )
    {
        GPIOPinWrite( GPIO_PORTF_BASE, GPIO_PIN_0, 1 );
    }
    else
    {
        GPIOPinWrite( GPIO_PORTF_BASE, GPIO_PIN_0, 0 );
    }
}

void debug(const char *string )
{
    (void)string;
    char ploc[256];

    hwaddr_cpy( &MAC(ploc)->sourc, &vMac_localaddr );
    hwaddr_cpy( &MAC(ploc)->dest, &vMac_broadcast );
    MAC(ploc)->type = 0x1987;
    MAC(ploc)->type = hton16( MAC(ploc)->type );

    int length = vstrlen( string );

    if( length < 242 )
    {
        vmemcpy( MACpayload(ploc), string, length );
        length += 14;
    }
    else
    {
        vmemcpy( MACpayload(ploc), string, 242 );
        length = 256;
    }

    vEthernetWrite( ploc, length );
}

char vGenerateTrueRandom( void )
{
    // todo: Generate a true random number using the noise on the ADC
    // module
    return 1;

    // Enable the ADC peripheral
    SysCtlPeripheralEnable( SYSCTL_PERIPH_ADC0 );
}

